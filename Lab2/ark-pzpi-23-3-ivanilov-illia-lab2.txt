ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 
Кафедра «Програмної інженерії»
 
 




ЗВІТ
з лабораторної роботи № 2
з дисципліни «Аналіз та рефакторинг коду»
 



 










Виконав:                                                                       ст. викладач кафедри ПІ:
ст. гр. ПЗПІ-23-3                                                                Сокорчук Ігор Петрович
Іванілов І. В.











Харків 2025








1 ІСТОРІЯ ЗМІН
Таблиця 1.1 - Історія змін
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	16.12.2025
	0.1
	Створено звіт
	2 ЗАВДАННЯ
Ознайомитися з процесом розробки серверної частини програмної системи, включаючи проектування бази даних (БД), розробку API для взаємодії з клієнтами, та перевірку (тестування) їхньої взаємодії. Оволодіти методами проектування діаграм UML та ER, розробки БД, програмної реалізації API, а також роботи з репозиторіями Git та створення технічної документації.
1. Розробити будову програмної системи, включаючи:
1.1. Формулювання архітектурних рішень для серверної частини, клієнтських взаємодій та бази даних
1.2. Опис моделей, які використовуються в системі, та визначення зв’язків між ними
2. Створити UML-діаграму прецедентів для серверної частини системи, а саме:
2.1. Використати UML для опису основних випадків використання серверної частини
2.2. Відобразити дії користувачів та їх взаємодію із системою
3. Створити ER-діаграму даних, що включає:
3.1. Визначення сутностей, атрибутів та зв’язків між ними
3.2. Візуалізацію структури даних засобами ER-діаграми
4. Розробити базу даних програмної системи, включаючи:
4.1. Проектування структури таблиць на основі ER-діаграми
4.2. Опис схеми нормалізації даних відповідно до 1NF, 2NF та 3NF
5. Створити діаграму структури бази даних, яка повинна містити:
5.1. Усі таблиці БД
5.2. Зв’язки між таблицями
5.3. Первинні та зовнішні ключі, а також інші обмеження
6. Розробити функції роботи з базою даних (ORM або CoRM):
6.1. Реалізувати методи доступу до БД
6.2. Забезпечити підтримку CRUD-операцій (Create, Read, Update, Delete) для основних сутностей
7. Розробити API для взаємодії серверної частини з клієнтами, а саме:
7.1. Визначити тип API (REST)
7.2. Описати ендпоінти API, методи (GET, POST, PUT, DELETE) та їх параметри
8. Створити специфікацію розробленого API, що повинна містити:
8.1. Опис кожного ендпоінту
8.2. Формат запитів та відповідей
8.3. Приклади використання API
9. Реалізувати серверну частину системи, включаючи:
9.1. Програмну реалізацію API
9.2. Функції роботи з базою даних
9.3. Забезпечення коректної взаємодії API з БД
10. Перевірити роботу створеного програмного коду серверної частини системи, включаючи:
10.1. Проведення тестування реалізованих функцій
10.2. Перевірку взаємодії API з базою даних


3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Архітектурні рішення для серверної частини системи
Система будується за клієнт-серверною архітектурою з чітким поділом на три основні рівні: інтерфейс користувача (web), серверну логіку (Next.js API) та рівень зберігання даних (БД).
Серверна частина реалізується засобами Next.js як єдина веб-програма, що поєднує UI та API-шар. Для обробки бізнес-логіки використовуються API-маршрути (Next.js API Routes) для таких клієнтів:
   * веб-клієнт (браузерна версія),
   * віртуальний IoT-клієнт.
Архітектурно сервер поділяється на декілька логічних шарів:
   * контролери (API-обробники): приймають HTTP-запити, виконують валідацію вхідних даних, викликають сервісну логіку та формують HTTP-відповіді у форматі JSON;
   * сервісний (бізнес) шар: містить правила розрахунку добової норми, побудови графіка, аналізу прийомів води, формування рекомендацій та створення сповіщень;
   * шар доступу до даних: відповідає за зчитування та запис інформації в БД (через ORM Prisma до PostgreSQL).
Усі сторонні інтеграції (служба погоди, push-сервіс для сповіщень) інкапсульовані в окремих сервісних модулях. Це спрощує заміну або розширення інтеграцій. Також передбачено використання токен-базованої аутентифікації (наприклад, JWT) з розподілом ролей користувача (User, Admin, Super Admin). Перевірка прав доступу виконується на рівні API-маршрутів та сервісного шару.


3.2 Моделі бази даних
1. Модель користувача, яка містить реєстраційні дані та параметри профілю (вага, рівень активності, тип цілі, час сну й пробудження, роль, статус). Відповідає за: ідентифікацію користувача, налаштування профілю, визначення ролей доступу.
2. Добовий гідратаційний план, сформований для конкретного користувача на конкретну дату. Містить цільову норму, підсумкові показники за день (загальний об’єм, кількість прийомів води, відхилення від норми). Відповідає за: побудову та відстеження плану споживання води протягом дня.
3. Окремий прийом води, зафіксований IoT-клієнтом. Містить час і об’єм спожитої порції. Відповідає за: формування реальної картини споживання води впродовж дня.
4. Запис фізичної активності користувача за день: тип навантаження, інтенсивність, час, тривалість. Може містити додатковий обсяг води, рекомендований системою. Відповідає за: вплив активності на добову норму та коригування гідратаційного плану.
5. Автоматично згенерована порада, що базується на поведінці користувача: частоті прийомів, відставанні від норми, великих порціях або активності. Може бути прив’язана до конкретного Intake. Відповідає за: формування персональних рекомендацій, що допомагають дотримуватися плану.
6. Факт відправлення повідомлення користувачу: нагадування, попередження або рекомендації. Містить текст, тип, канал доставки та статус. Відповідає за: донесення рекомендацій та важливої інформації до користувача.
3.3 UML-діаграма
1. User (звичайний користувач)
User — це основний актор системи, для якого і створено весь функціонал гідратації.
   1. Доступ до системи:
   * Користувач проходить реєстрацію, створюючи обліковий запис.
   * Потім виконує авторизацію, щоб отримати доступ до свого профілю, планів і статистики.
2) Керування профілем – користувач може змінювати особисті параметри, від яких залежить розрахунок норми води:
   * редагувати власні параметри (вага, рівень активності, ціль гідратації, час сну/пробудження);
   * змінювати мову інтерфейсу;
   * змінювати одиниці вимірювання (мл / унції).
   3. Щоденне використання – це основний сценарій роботи користувача з системою:
   * переглянути щоденний графік — як розподілена норма протягом дня;
   * переглянути поточний прогрес — скільки вже випито і скільки залишилось;
   * переглянути рекомендації — поради щодо режиму пиття;
   * додавання даних активностей — користувач фіксує свої фізичні навантаження, щоб система могла коригувати план.
2. Admin – працює не зі своїми даними, а з усією системою на рівні користувачів і статистики.
   1. Управління користувачами – адміністратор має доступ до всіх облікових записів:
   * переглянути список користувачів — базовий огляд усіх зареєстрованих;
   * редагувати профіль користувача — змінити параметри, допомогти виправити помилки, змінити статус;
   * видалити користувача — деактивація або повне видалення облікового запису.
   2. Формування статистики – адміністратор може формувати й переглядати загальну статистику системи:
   * активність користувачів;
   * виконання добової норми;
   * динаміка використання системи.
   3. Керування сповіщеннями – адміністратор також впливає на комунікацію з користувачами:
   * змінення шаблону сповіщень — правка текстів, тону, структури повідомлень;
   * керування типами сповіщень, які надсилаються в різних ситуаціях (нагадування, попередження, підсумки).
3. Super Admin – це найвищий рівень доступу. Він успадковує всі можливості Admin і додатково керує конфігурацією системи.
   1. Керування ролями системи –  визначає, хто й що може робити:
   * призначає ролі (User / Admin / Super Admin);
   * змінює ролі існуючим користувачам;
   * фактично керує моделлю доступу до всього функціоналу.
   2. Керування системними налаштуваннями – це глибинний вплив на поведінку системи:
   * налаштування параметрів, які впливають на розрахунок норм води;
   * зміна глобальних політик роботи (наприклад, дефолтні одиниці вимірювання, загальні межі тощо).
   3. Керування мовними пакетами та локалізацією – контролює підтримку різних мов:
   * додавання мовних пакетів — нові переклади;
   * вмикання/вимикання мовних пакетів — контроль доступних мов у системі;
   * робота з локалізацією через кейс «Керування мовними пакетами», який включений у «Керування системними налаштуваннями».
   4. Зміна глобального розрахунку норми води
Супер адміністратор може змінити глобальні формули та алгоритми розрахунку добової норми, щоб уся система працювала за оновленими правилами (наприклад, додати врахування клімату чи нових медичних рекомендацій).
  

Рис 3.1 – UML-діаграма




3.4 Опис ER-діаграми
        Діаграма орієнтована на відображення даних про користувачів, їх щоденні плани гідратації, фактичне споживання води, фізичну активність, рекомендації та сповіщення.
1. User
Сутність User зберігає дані облікового запису користувача та основні параметри, що впливають на розрахунок норми води.
Атрибути: електронна пошта, пароль, вага, рівень активності, тип цілі, час пробудження, дата народження, роль і статус користувача.
Зв’язки:
      * один користувач може мати кілька щоденних планів (User 1–N DailyPlan);
      * користувач отримує сповіщення через рекомендації (User 1–N Notification, опосередковано).
2. DailyPlan
Сутність DailyPlan представляє добовий план споживання води для конкретного користувача.
Атрибути: дата, цільовий обсяг води, загальний обсяг випитої води, відхилення від норми та кількість прийомів води за день.
Зв’язки:
      * кожен план належить одному користувачу (DailyPlan N–1 User);
      * один план включає кілька прийомів води (DailyPlan 1–N Intake);
      * один план може містити кілька записів фізичної активності (DailyPlan 1–N Activity);
      * на основі даних плану формуються рекомендації (DailyPlan 1–N Recommendation, логічно).
3. Intake
Сутність Intake описує окремий факт споживання води.
Атрибути: обсяг випитої води та час прийому.
Зв’язки:
      * кожен прийом води відноситься до одного добового плану (Intake N–1 DailyPlan);
      * прийом води може бути підставою для формування рекомендації (Intake 1–N Recommendation).
4. Activity
Сутність Activity зберігає дані про фізичну активність користувача протягом дня.
Атрибути: тип активності, інтенсивність, час початку та завершення, тривалість і додатковий рекомендований обсяг води.
Зв’язки:
      * кожна активність пов’язана з конкретним добовим планом (Activity N–1 DailyPlan).
5. Recommendation
Сутність Recommendation містить рекомендації, автоматично сформовані системою на основі аналізу поведінки користувача.
Атрибути: тип рекомендації, текст повідомлення та рівень важливості.
Зв’язки:
      * рекомендація може бути пов’язана з конкретним прийомом води (Recommendation N–1 Intake);
      * на основі рекомендацій формуються сповіщення (Recommendation 1–N Notification).
6. Notification
Сутність Notification представляє сповіщення, надіслане користувачу.
Атрибути: тип сповіщення, заголовок, текст, статус, час надсилання та канал доставки.
Зв’язки:
      * кожне сповіщення пов’язане з однією рекомендацією (Notification N–1 Recommendation).
  

Рис 3.2 – ER-діаграма 






3.5 Нормалізація ER-діаграми
Для початку нормалізації потрібно сформувати універсальне відношення с визначеними функціональними залежностями.
  

Рис 3.3 – сформоване універсальне відношення
        У даному універсальному відношенню всі неключові атрибути є атомарними, тобто кожне поле містить одне значення і не має вкладених списків або повторюваних груп, тому можна зробити висновок, що відношення знаходится в 1НФ. 
        Наступним кроком є приведення відношення до 2НФ. Відношення можна вважати в 2НФ при умові, якщо воно знаходиться в 1НФ та кожен неключовий атрибут повністю функціонально залежить від первинного ключа відношення. З даного відношення, приведеного на рисунку 3.3  можна зробити висновок, що таким первинним ключем є activity_id, notification_id. 
  

Рис 3.4 - результат приведення відношення до 2НФ
        Наступним кроком є приведення до 3НФ. Відношення знаходиться в 3НФ при умові, що воно знаходиться в 2НФ та між неключовими атрибутами немає транзитивних залежностей.
Транзитивною залежністю між неключовими атрибутами називається залежність, коли неключовий атрибут відношення можна визначити не тільки за  первинним ключем. В разі виникнення транзитивної залежності, такі атрибути виносяться в окремі таблиці.
Проаналізувавши функціональні залежності універсального відношення, можна побачити, що існує транзитивна залежність між атрибутами, які пов’язані з щоденним планом та користувачем, рекомендацією та окремими прийомом води. 
  

Рис 3.5 – Результат приведення таблиць до 3НФ
Таким чином, отримали схему бази даних з п’яти таблиць, в якій кожна таблиця перебуває в 3НФ. Тобто кожен неключовий атрибут залежить тільки від первинного ключа. Ці таблиці повністю відповідають остаточній версії схеми бази даних з курсового проекту.
3.6 Методи доступу до БД через ORM
У проєкті реалізовано доступ до бази даних через ORM Prisma. Як СУБД використовується PostgreSQL.
Доступ до БД виконується через Prisma Client, який генерується на основі схеми даних. У серверній частині Next.js API створюється єдиний екземпляр PrismaClient, який повторно використовується між запитами, щоб уникнути зайвого відкриття з’єднань. Кожен API-ендпоінт працює за однаковою схемою: приймає HTTP-запит, валідовує вхідні дані, викликає відповідний метод Prisma Client для читання або запису даних, а потім повертає відповідь у форматі JSON. Код для підключення до БД див. в Додатку Б.
3.7 CRUD-операції для основних сутностей
Для сутності User реалізовано створення облікового запису під час реєстрації. Читання даних користувача виконується для відображення профілю та прав доступу. Оновлення використовується для зміни статусу, ролі або базових параметрів.
Для сутності DailyPlan реалізовано створення плану на конкретну дату для конкретного користувача. Читання використовується для отримання плану за день або історії планів за період. Оновлення застосовується при перерахунку добової норми, зміні цілі або при оновленні агрегатних полів total_intake_ml, deviation_ml, amount_of_intakes. Видалення застосовується адміністративно або під час очищення тестових даних.
Для сутності Intake реалізовано створення прийому води, який приходить від IoT-клієнта. Читання використовується для показу хронології прийомів за день. Видалення використовується для видалення помилкових записів і коректного перерахунку підсумків плану.
Для сутності Recommendation реалізовано створення рекомендацій серверною логікою на основі аналізу Intake, Activity та поточного стану DailyPlan. Читання використовується для відображення рекомендацій користувачу. Видалення використовується, якщо рекомендації перегенеровуються для дня або потрібно очистити тестові дані (див. Додаток Б).
3.8 Опис типу API та реалізованих ендпоінтів
У проєкті використовується REST API. REST представляє собою підхід, у якому кожна сутність системи доступна як ресурс, а дії над ресурсами виконуються стандартними HTTP-методами. Для створення використовується POST, для читання GET, для оновлення PATCH, для видалення DELETE. Дані передаються у форматі JSON, а сервер повертає структуровані відповіді з кодами статусу HTTP.
Кожна сутність має наступні ендпоінти:
        GET:  /api/{resource} – Отримати список записів (з фільтрацією);
POST /api/{resource} – Створити новий запис;
GET /api/{resource}/{id} – Отримати запис за ID;
PATCH /api/{resource}/{id} – Оновити запис;
DELETE /api/{resource}/{id} – Видалити запис;
3.9 Специфікація розробленого API
1) Запит: POST – /api/users
Опис: використовується для створення нового користувача в системі. Під час виконання запиту створюється новий обліковий запис із заданими роллю та статусом.
Тіло запиту:
{
"email": "newuser@example.com",
"password": "securePassword123",
"role": "user",
"status": "active"
}
Статус відповіді:
201 Created
Відповідь:
{
"ok": true,
"data": {
        "user_id": 1,
        "email": "newuser@example.com",
        "password": "securePassword123",
        "role": "user",
        "status": "active",
        "createdAt": "2024-01-01T12:00:00Z",
         "updatedAt": "2024-01-01T12:00:00Z"
        }
}
2) Запит: GET – /api/users?role=user&status=active
Опис: використовується для отримання списку користувачів із можливістю фільтрації за роллю та статусом. Призначений для адміністративного перегляду користувачів системи.
Тіло запиту:
Не використовується. Параметри передаються через рядок запиту.
Статус відповіді:
200 OK
Відповідь:
{
  "ok": true,
  "data": [
  {
    "user_id": 1,
    "email": "user1@example.com",
    "role": "user",
    "status": "active"
  },
  {
    "user_id": 2,
    "email": "user2@example.com",
    "role": "user",
    "status": "active"
  }
]
}
3) Запит: PATCH – /api/users/1
Опис: використовується для часткового оновлення даних користувача. Дозволяє змінювати окремі атрибути, наприклад статус користувача.
Тіло запиту:
{
"status": "inactive"
}
Статус відповіді:
200 OK
Відповідь:
{
  "ok": true,
  "data": {
  "user_id": 1,
  "email": "user@example.com",
  "role": "user",
  "status": "inactive",
  "updatedAt": "2024-01-01T13:00:00Z"
  }
}


4) Запит: POST – /api/daily-plans
Опис: використовується для створення щоденного плану споживання води для конкретного користувача на задану дату.
Тіло запиту:
{
  "user_id": 1,
   "date": "2024-01-15T00:00:00Z",
  "target": 2500.0
}
Статус відповіді:
201 Created
Відповідь:
{
 "ok": true,
 "data": {
  "dailyplan_id": 1,
  "user_id": 1,
  "date": "2024-01-15T00:00:00Z",
  "target": 2500.0,
  "total_intake_ml": null,
  "deviation_ml": null,
  "amount_of_intakes": null,
  "createdAt": "2024-01-15T08:00:00Z",
  "updatedAt": "2024-01-15T08:00:00Z"
  }
}
5) Запит: POST – /api/intakes
Опис: використовується для додавання окремого прийому води в межах щоденного плану. Після створення запису система може автоматично оновлювати агреговані значення відповідного плану.
Тіло запиту:
{
  "dailyplan_id": 1,
  "volume_ml": 300.0,
  "intake_time": "2024-01-15T10:30:00Z"
}
Статус відповіді:
201 Created
Відповідь:
{
   "ok": true,
   "data": {
   "intake_id": 1,
   "dailyplan_id": 1,
   "volume_ml": 300.0,
   "intake_time": "2024-01-15T10:30:00Z",
  "createdAt": "2024-01-15T10:30:00Z",
  "updatedAt": "2024-01-15T10:30:00Z"
  }
}
 ВИСНОВКИ
У межах даного проекту було спроектовано та частково реалізовано серверну частину інформаційної системи контролю та планування щоденного споживання води користувачами. У результаті виконання роботи було здійснено:
      * сформульовано архітектурні рішення серверної частини системи на основі клієнт–серверної архітектури з використанням Next.js API Routes як бекенд-рівня, що забезпечує обробку HTTP-запитів, бізнес-логіку та взаємодію з базою даних;
      * визначено ролі користувачів системи (User, Admin, Super Admin) та побудовано UML-діаграму варіантів використання, яка відображає дії кожного актора та їхню взаємодію з функціональністю системи;
      * спроєктовано ER-діаграму предметної області, що описує основні сутності системи (користувачі, профілі, щоденні плани, прийоми води, активність, рекомендації, сповіщення) та зв’язки між ними;
      * виконано поетапну нормалізацію бази даних до третьої нормальної форми (3NF), що дозволило усунути надлишковість, транзитивні залежності та забезпечити логічну цілісність даних;
      * розроблено логічну та фізичну структуру бази даних з чітко визначеними первинними та зовнішніми ключами, що забезпечують коректні зв’язки між таблицями;
      * обрано ORM Prisma у поєднанні з реляційною базою даних (PostgreSQL / MySQL), що дозволяє реалізувати типобезпечний та зручний доступ до даних у серверній частині застосунку;
      * описано CRUD-операції для основних сутностей системи, зокрема користувачів, щоденних планів та прийомів води;
      * спроєктовано REST API, визначено набір ендпоінтів, HTTP-методи (GET, POST, PATCH, DELETE), параметри запитів та структуру відповідей;
      * підготовлено специфікацію API з описом кожного ендпоінту, форматами запитів і відповідей, а також прикладами використання для тестування та подальшої інтеграції з клієнтською частиною;
      * продемонстровано підхід до тестування ендпоінтів шляхом використання прикладів HTTP-запитів для перевірки коректності роботи серверної логіки.


ДОДАТОК А
Відеозапис
        Відеозапис презентації результатів практичної роботи: https://youtu.be/7uWvm0uccsc
00:16 Архітектурні рішення
01:22 Моделі бази даних
02:24 UML-діаграма
04:54 ER-діаграма
06:25 Нормалізація ER-діаграми
07:16 Методи доступу до БД
07:20 Опис CRUD-операцій
08:36 Опис API
08:27 Запити до таблиці користувачів
10:23 Запити до таблиці щоденних планів


ДОДАТОК Б
Приклад програмного коду
Код Б.1 – Підключення до БД
import "dotenv/config";
import { defineConfig, env } from "prisma/config";


export default defineConfig({
    schema: "prisma/schema.prisma",
    migrations: {
        path: "prisma/migrations",
    },
    datasource: {
        url: env("DATABASE_URL"),
    },
});


Код Б.2 – Взаємодія серверу з БД
import { prisma } from "@/lib/prisma";
import { NotFoundError, ConflictError } from "@/lib/http/errors";
import { z } from "zod";


const createUserSchema = z.object({
    email: z.string().email(),
    password: z.string().min(1),
    role: z.string().optional(),
    status: z.string().optional(),
});


const updateUserSchema = z.object({
    email: z.string().email().optional(),
    password: z.string().min(1).optional(),
    role: z.string().optional(),
    status: z.string().optional(),
});


export type CreateUserInput = z.infer<typeof createUserSchema>;
export type UpdateUserInput = z.infer<typeof updateUserSchema>;


export const userService = {
    async findAll(filters?: {
        email?: string;
        role?: string;
        status?: string;
    }) {
        const where: any = {};
        if (filters?.email) {
            where.email = { contains: filters.email, mode: "insensitive" };
        }
        if (filters?.role) {
            where.role = filters.role;
        }
        if (filters?.status) {
            where.status = filters.status;
        }
        return prisma.user.findMany({ where });
    },


    async findById(id: number) {
        const user = await prisma.user.findUnique({
            where: { user_id: id },
        });
        if (!user) {
            throw new NotFoundError("User", id.toString());
        }
        return user;
    },


    async create(data: unknown) {
        const validated = createUserSchema.parse(data);


        const existing = await prisma.user.findUnique({
            where: { email: validated.email },
        });
        if (existing) {
            throw new ConflictError("User with this email already exists");
        }


        return prisma.user.create({
            data: validated,
        });
    },


    async update(id: number, data: unknown) {
        await this.findById(id);
        const validated = updateUserSchema.parse(data);
        if (validated.email) {
            const existing = await prisma.user.findUnique({
                where: { email: validated.email },
            });
            if (existing && existing.user_id !== id) {
                throw new ConflictError("User with this email already exists");
            }
        }
        return prisma.user.update({
            where: { user_id: id },
            data: validated,
        });
    },


    async delete(id: number) {
        await this.findById(id);
        await prisma.user.delete({
            where: { user_id: id },
        });
        
        const maxId = await prisma.user.aggregate({
            _max: { user_id: true },
        });
        const nextId = maxId._max.user_id ? maxId._max.user_id + 1 : 1;
        await prisma.$executeRawUnsafe(
            `ALTER SEQUENCE users_user_id_seq RESTART WITH ${nextId};`
        );
    },
};
Код Б.3 – Взаємодія серверної частини з клієнтами (обробка HTTP-запитів)
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const filters = {
      email: parseQueryString(searchParams.get('email')),
      role: parseQueryString(searchParams.get('role')),
      status: parseQueryString(searchParams.get('status')),
    }
    const users = await userService.findAll(filters)
    return successResponse(users)
  } catch (error) {
    return handleError(error)
  }
}


export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const user = await userService.create(body)
    return successResponse(user, 201)
  } catch (error) {
    return handleError(error)
  }
}




export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const userId = parseId(id)
    const user = await userService.findById(userId)
    return successResponse(user)
  } catch (error) {
    return handleError(error)
  }
}


export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const userId = parseId(id)
    const body = await request.json()
    const user = await userService.update(userId, body)
    return successResponse(user)
  } catch (error) {
    return handleError(error)
  }
}


export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const userId = parseId(id)
    await userService.delete(userId)
    return noContentResponse()
  } catch (error) {
    return handleError(error)
  }
}